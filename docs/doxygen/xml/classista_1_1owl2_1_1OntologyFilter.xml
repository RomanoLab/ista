<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classista_1_1owl2_1_1OntologyFilter" kind="class" language="C++" prot="public">
    <compoundname>ista::owl2::OntologyFilter</compoundname>
    <includes refid="ontology__filter_8hpp" local="no">ontology_filter.hpp</includes>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classista_1_1owl2_1_1OntologyFilter_1ad5e0765e3465ad335ea4d9b681eee02c" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; const <ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &gt;</type>
        <definition>std::shared_ptr&lt;const Ontology&gt; ista::owl2::OntologyFilter::ontology_</definition>
        <argsstring></argsstring>
        <name>ontology_</name>
        <qualifiedname>ista::owl2::OntologyFilter::ontology_</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="232" column="21" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" bodystart="232" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classista_1_1owl2_1_1OntologyFilter_1a8a7a81ea998c3436b63f0e581cc289a2" prot="private" static="no" mutable="no">
        <type><ref refid="structista_1_1owl2_1_1FilterCriteria" kindref="compound">FilterCriteria</ref></type>
        <definition>FilterCriteria ista::owl2::OntologyFilter::criteria_</definition>
        <argsstring></argsstring>
        <name>criteria_</name>
        <qualifiedname>ista::owl2::OntologyFilter::criteria_</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="233" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" bodystart="233" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>ista::owl2::OntologyFilter::OntologyFilter</definition>
        <argsstring>(const Ontology &amp;ontology)</argsstring>
        <name>OntologyFilter</name>
        <qualifiedname>ista::owl2::OntologyFilter::OntologyFilter</qualifiedname>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &amp;</type>
          <declname>ontology</declname>
        </param>
        <briefdescription>
<para>Construct a filter for the given ontology. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ontology</parametername>
</parameternamelist>
<parameterdescription>
<para>The ontology to filter </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="96" column="14" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="14" bodyend="15"/>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1a75f1abdc1d4e8031350a0e4cde907ea6" compoundref="ontology__filter_8cpp" startline="234" endline="237">excludeIndividuals</referencedby>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1a888c96adeb52623f9ae2d980f2b284d6" compoundref="ontology__filter_8cpp" startline="244" endline="247">includeClassHierarchy</referencedby>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1a666abd422d7662f1adce40e97975c4f6" compoundref="ontology__filter_8cpp" startline="254" endline="257">includeDeclarations</referencedby>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1ac47d8b428dc9f048bf3d3544d92c01d1" compoundref="ontology__filter_8cpp" startline="249" endline="252">includePropertyHierarchy</referencedby>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1acb0e23e9328763b75ddf35f858fa276a" compoundref="ontology__filter_8cpp" startline="229" endline="232">withClasses</referencedby>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1a5a68f5fed2201b121f54c872af137f1b" compoundref="ontology__filter_8cpp" startline="224" endline="227">withIndividuals</referencedby>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1a898402f739529104fe3288c67a945d1b" compoundref="ontology__filter_8cpp" startline="239" endline="242">withMaxDepth</referencedby>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a7c6058f61917b34ee12ac3e600f5d1c3" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>ista::owl2::OntologyFilter::OntologyFilter</definition>
        <argsstring>(std::shared_ptr&lt; const Ontology &gt; ontology)</argsstring>
        <name>OntologyFilter</name>
        <qualifiedname>ista::owl2::OntologyFilter::OntologyFilter</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; const <ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &gt;</type>
          <declname>ontology</declname>
        </param>
        <briefdescription>
<para>Construct a filter with shared ownership of ontology. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ontology</parametername>
</parameternamelist>
<parameterdescription>
<para>Shared pointer to the ontology to filter </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="102" column="14" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="17" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a07975b01d94c1a58008728892c77f60b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::filterByIndividuals</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;iris) const</argsstring>
        <name>filterByIndividuals</name>
        <qualifiedname>ista::owl2::OntologyFilter::filterByIndividuals</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>iris</declname>
        </param>
        <briefdescription>
<para>Extract a subgraph containing specific individuals. </para>
        </briefdescription>
        <detaileddescription>
<para>Includes all axioms that reference the specified individuals, along with their class assertions and property assertions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iris</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of individual IRIs to include </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the filtered ontology </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="113" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="28" bodyend="30"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a6f6d0a43b2a623ad17cf80e8a0eff87b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::filterByClasses</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;class_iris) const</argsstring>
        <name>filterByClasses</name>
        <qualifiedname>ista::owl2::OntologyFilter::filterByClasses</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>class_iris</declname>
        </param>
        <briefdescription>
<para>Filter by class membership. </para>
        </briefdescription>
        <detaileddescription>
<para>Includes all individuals that are instances of the specified classes (according to <ref refid="classista_1_1owl2_1_1ClassAssertion" kindref="compound">ClassAssertion</ref> axioms), along with their related axioms.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>class_iris</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of class IRIs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the filtered ontology </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="124" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="32" bodyend="42"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a1e8f46ed127f1d4c19f0cdce53adcb0d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::filterByProperty</definition>
        <argsstring>(const IRI &amp;property, const Literal &amp;value) const</argsstring>
        <name>filterByProperty</name>
        <qualifiedname>ista::owl2::OntologyFilter::filterByProperty</qualifiedname>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>property</declname>
        </param>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1Literal" kindref="compound">Literal</ref> &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Filter by property value. </para>
        </briefdescription>
        <detaileddescription>
<para>Includes individuals that have the specified property with the given value. For <ref refid="classista_1_1owl2_1_1DataPropertyAssertion" kindref="compound">DataPropertyAssertion</ref> axioms, matches against the literal value. For <ref refid="classista_1_1owl2_1_1ObjectPropertyAssertion" kindref="compound">ObjectPropertyAssertion</ref> axioms, matches against the target individual&apos;s <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>property</parametername>
</parameternamelist>
<parameterdescription>
<para>The property <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> to filter by </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The literal value to match </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the filtered ontology </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="137" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="44" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1aa9bb64a055d688ee2012c389df99c5f9" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::filterByObjectProperty</definition>
        <argsstring>(const IRI &amp;property, const IRI &amp;target) const</argsstring>
        <name>filterByObjectProperty</name>
        <qualifiedname>ista::owl2::OntologyFilter::filterByObjectProperty</qualifiedname>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>property</declname>
        </param>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>target</declname>
        </param>
        <briefdescription>
<para>Filter by object property target. </para>
        </briefdescription>
        <detaileddescription>
<para>Includes individuals that have the specified object property pointing to the given target individual.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>property</parametername>
</parameternamelist>
<parameterdescription>
<para>The object property <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>target</parametername>
</parameternamelist>
<parameterdescription>
<para>The target individual <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the filtered ontology </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="149" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="63" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a97f9a68e6632707e6b50238cf9e57faa" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::extractNeighborhood</definition>
        <argsstring>(const IRI &amp;seed, int depth) const</argsstring>
        <name>extractNeighborhood</name>
        <qualifiedname>ista::owl2::OntologyFilter::extractNeighborhood</qualifiedname>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>seed</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
<para>Extract k-hop neighborhood around seed individual(s). </para>
        </briefdescription>
        <detaileddescription>
<para>Uses BFS to traverse the ontology graph, following property assertions up to the specified depth. Depth 0 includes only the seed node(s).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The seed individual <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum number of hops (property edges) to traverse </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the neighborhood subgraph </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="161" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="91" bodyend="93"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a97f9a68e6632707e6b50238cf9e57faa" compoundref="ontology__filter_8cpp" startline="91" endline="93">extractNeighborhood</references>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1a97f9a68e6632707e6b50238cf9e57faa" compoundref="ontology__filter_8cpp" startline="91" endline="93">extractNeighborhood</referencedby>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a419895577ae3e0375f90ee0904040fbc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::extractNeighborhood</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;seeds, int depth) const</argsstring>
        <name>extractNeighborhood</name>
        <qualifiedname>ista::owl2::OntologyFilter::extractNeighborhood</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>seeds</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
<para>Extract k-hop neighborhood around multiple seed individuals. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>seeds</parametername>
</parameternamelist>
<parameterdescription>
<para>Set of seed individual IRIs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>depth</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum number of hops to traverse </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the neighborhood subgraph </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="170" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="95" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a11640efd18c237dcd1742cc07b52c65e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::extractPath</definition>
        <argsstring>(const IRI &amp;start, const IRI &amp;end) const</argsstring>
        <name>extractPath</name>
        <qualifiedname>ista::owl2::OntologyFilter::extractPath</qualifiedname>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>start</declname>
        </param>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>end</declname>
        </param>
        <briefdescription>
<para>Extract path(s) between two individuals. </para>
        </briefdescription>
        <detaileddescription>
<para>Uses BFS to find if a path exists between start and end individuals through property assertions. Includes all axioms on the shortest path(s).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>start</parametername>
</parameternamelist>
<parameterdescription>
<para>Starting individual <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>Target individual <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the path subgraph (empty if no path exists) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="182" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="109" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a00f2153862d854e1618bc9f8b24ad5b5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::randomSample</definition>
        <argsstring>(size_t n, unsigned int seed=42) const</argsstring>
        <name>randomSample</name>
        <qualifiedname>ista::owl2::OntologyFilter::randomSample</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>seed</declname>
          <defval>42</defval>
        </param>
        <briefdescription>
<para>Random sampling of individuals. </para>
        </briefdescription>
        <detaileddescription>
<para>Randomly selects n individuals and extracts their axioms. Useful for creating training/test splits or sampling large ontologies.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of individuals to sample </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>seed</parametername>
</parameternamelist>
<parameterdescription>
<para>Random seed for reproducibility </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the sampled subgraph </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="194" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="119" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a05fbcd33f210d57cdf321e0d96297b60" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::applyFilter</definition>
        <argsstring>(const FilterCriteria &amp;criteria) const</argsstring>
        <name>applyFilter</name>
        <qualifiedname>ista::owl2::OntologyFilter::applyFilter</qualifiedname>
        <param>
          <type>const <ref refid="structista_1_1owl2_1_1FilterCriteria" kindref="compound">FilterCriteria</ref> &amp;</type>
          <declname>criteria</declname>
        </param>
        <briefdescription>
<para>Apply custom filter criteria. </para>
        </briefdescription>
        <detaileddescription>
<para>Provides maximum flexibility by allowing arbitrary filtering logic through the <ref refid="structista_1_1owl2_1_1FilterCriteria" kindref="compound">FilterCriteria</ref> struct.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>criteria</parametername>
</parameternamelist>
<parameterdescription>
<para>The filter criteria to apply </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the filtered ontology </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="205" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="139" bodyend="218"/>
        <references refid="structista_1_1owl2_1_1FilterCriteria_1abb64413e85f97a22742614663b34434e" compoundref="ontology__filter_8hpp" startline="52">ista::owl2::FilterCriteria::custom_filter</references>
        <references refid="structista_1_1owl2_1_1FilterCriteria_1a802cc8f0c0ce656cc8f3295907d16c36" compoundref="ontology__filter_8hpp" startline="34">ista::owl2::FilterCriteria::exclude_individuals</references>
        <references refid="structista_1_1owl2_1_1FilterCriteria_1aea7192979aae25c94580f410b1d8d7fb" compoundref="ontology__filter_8hpp" startline="31">ista::owl2::FilterCriteria::include_classes</references>
        <references refid="structista_1_1owl2_1_1FilterCriteria_1a164bd8f86d499bba709f0b50ade662fc" compoundref="ontology__filter_8hpp" startline="28">ista::owl2::FilterCriteria::include_individuals</references>
        <references refid="structista_1_1owl2_1_1FilterCriteria_1a54c61a9c7e8661f961dcec5a9db5cd31" compoundref="ontology__filter_8hpp" startline="40">ista::owl2::FilterCriteria::max_depth</references>
        <references refid="structista_1_1owl2_1_1FilterCriteria_1a5900e9c421d1f65fb8d9d82345e1f1bd" compoundref="ontology__filter_8hpp" startline="37">ista::owl2::FilterCriteria::property_value_filters</references>
        <referencedby refid="classista_1_1owl2_1_1OntologyFilter_1a42f58574eeb431335d08f914dd4cf7f1" compoundref="ontology__filter_8cpp" startline="259" endline="261">execute</referencedby>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a5a68f5fed2201b121f54c872af137f1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" kindref="member">OntologyFilter</ref> &amp;</type>
        <definition>OntologyFilter &amp; ista::owl2::OntologyFilter::withIndividuals</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;iris)</argsstring>
        <name>withIndividuals</name>
        <qualifiedname>ista::owl2::OntologyFilter::withIndividuals</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>iris</declname>
        </param>
        <briefdescription>
<para>Builder pattern: start building a filter. </para>
        </briefdescription>
        <detaileddescription>
<para>Returns *this for method chaining. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="212" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="224" bodyend="227"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" compoundref="ontology__filter_8cpp" startline="14" endline="15">OntologyFilter</references>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1acb0e23e9328763b75ddf35f858fa276a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" kindref="member">OntologyFilter</ref> &amp;</type>
        <definition>OntologyFilter &amp; ista::owl2::OntologyFilter::withClasses</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;class_iris)</argsstring>
        <name>withClasses</name>
        <qualifiedname>ista::owl2::OntologyFilter::withClasses</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>class_iris</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="213" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="229" bodyend="232"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" compoundref="ontology__filter_8cpp" startline="14" endline="15">OntologyFilter</references>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a75f1abdc1d4e8031350a0e4cde907ea6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" kindref="member">OntologyFilter</ref> &amp;</type>
        <definition>OntologyFilter &amp; ista::owl2::OntologyFilter::excludeIndividuals</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;iris)</argsstring>
        <name>excludeIndividuals</name>
        <qualifiedname>ista::owl2::OntologyFilter::excludeIndividuals</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>iris</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="214" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="234" bodyend="237"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" compoundref="ontology__filter_8cpp" startline="14" endline="15">OntologyFilter</references>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a898402f739529104fe3288c67a945d1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" kindref="member">OntologyFilter</ref> &amp;</type>
        <definition>OntologyFilter &amp; ista::owl2::OntologyFilter::withMaxDepth</definition>
        <argsstring>(int depth)</argsstring>
        <name>withMaxDepth</name>
        <qualifiedname>ista::owl2::OntologyFilter::withMaxDepth</qualifiedname>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="215" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="239" bodyend="242"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" compoundref="ontology__filter_8cpp" startline="14" endline="15">OntologyFilter</references>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a888c96adeb52623f9ae2d980f2b284d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" kindref="member">OntologyFilter</ref> &amp;</type>
        <definition>OntologyFilter &amp; ista::owl2::OntologyFilter::includeClassHierarchy</definition>
        <argsstring>(bool include)</argsstring>
        <name>includeClassHierarchy</name>
        <qualifiedname>ista::owl2::OntologyFilter::includeClassHierarchy</qualifiedname>
        <param>
          <type>bool</type>
          <declname>include</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="216" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="244" bodyend="247"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" compoundref="ontology__filter_8cpp" startline="14" endline="15">OntologyFilter</references>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1ac47d8b428dc9f048bf3d3544d92c01d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" kindref="member">OntologyFilter</ref> &amp;</type>
        <definition>OntologyFilter &amp; ista::owl2::OntologyFilter::includePropertyHierarchy</definition>
        <argsstring>(bool include)</argsstring>
        <name>includePropertyHierarchy</name>
        <qualifiedname>ista::owl2::OntologyFilter::includePropertyHierarchy</qualifiedname>
        <param>
          <type>bool</type>
          <declname>include</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="217" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="249" bodyend="252"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" compoundref="ontology__filter_8cpp" startline="14" endline="15">OntologyFilter</references>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a666abd422d7662f1adce40e97975c4f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" kindref="member">OntologyFilter</ref> &amp;</type>
        <definition>OntologyFilter &amp; ista::owl2::OntologyFilter::includeDeclarations</definition>
        <argsstring>(bool include)</argsstring>
        <name>includeDeclarations</name>
        <qualifiedname>ista::owl2::OntologyFilter::includeDeclarations</qualifiedname>
        <param>
          <type>bool</type>
          <declname>include</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="218" column="20" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="254" bodyend="257"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" compoundref="ontology__filter_8cpp" startline="14" endline="15">OntologyFilter</references>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a42f58574eeb431335d08f914dd4cf7f1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::execute</definition>
        <argsstring>() const</argsstring>
        <name>execute</name>
        <qualifiedname>ista::owl2::OntologyFilter::execute</qualifiedname>
        <briefdescription>
<para>Execute the built filter. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref> containing the filtered ontology </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="224" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="259" bodyend="261"/>
        <references refid="classista_1_1owl2_1_1OntologyFilter_1a05fbcd33f210d57cdf321e0d96297b60" compoundref="ontology__filter_8cpp" startline="139" endline="218">applyFilter</references>
        <referencedby refid="classista_1_1owl2_1_1Ontology_1a225834906bceea69d0ae3b37fa5b2e2c" compoundref="ontology_8cpp" startline="517" endline="520">ista::owl2::Ontology::createSubgraph</referencedby>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1aef35424e4000eaab2e5e9a5396b2a053" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::shared_ptr&lt; const <ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &gt;</type>
        <definition>std::shared_ptr&lt; const Ontology &gt; ista::owl2::OntologyFilter::getOntology</definition>
        <argsstring>() const</argsstring>
        <name>getOntology</name>
        <qualifiedname>ista::owl2::OntologyFilter::getOntology</qualifiedname>
        <briefdescription>
<para>Get the source ontology. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="229" column="21" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" bodystart="229" bodyend="229"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a1e50060e7d9bb34b82e3731fd2f67127" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt;</type>
        <definition>std::unordered_set&lt; IRI &gt; ista::owl2::OntologyFilter::getAllIndividuals</definition>
        <argsstring>() const</argsstring>
        <name>getAllIndividuals</name>
        <qualifiedname>ista::owl2::OntologyFilter::getAllIndividuals</qualifiedname>
        <briefdescription>
<para>Get all individuals mentioned in the ontology. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="240" column="24" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="267" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a16a45b4bdbcbbd29874511bc45161b94" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt;</type>
        <definition>std::unordered_set&lt; IRI &gt; ista::owl2::OntologyFilter::getIndividualsOfClass</definition>
        <argsstring>(const IRI &amp;class_iri) const</argsstring>
        <name>getIndividualsOfClass</name>
        <qualifiedname>ista::owl2::OntologyFilter::getIndividualsOfClass</qualifiedname>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>class_iri</declname>
        </param>
        <briefdescription>
<para>Get individuals that are instances of a class. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="245" column="24" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="277" bodyend="295"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a3a68e5352cc8b7aa3b1e8666cdd8836e" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_map&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref>, std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &gt;</type>
        <definition>std::unordered_map&lt; IRI, std::unordered_set&lt; IRI &gt; &gt; ista::owl2::OntologyFilter::buildAdjacencyList</definition>
        <argsstring>() const</argsstring>
        <name>buildAdjacencyList</name>
        <qualifiedname>ista::owl2::OntologyFilter::buildAdjacencyList</qualifiedname>
        <briefdescription>
<para>Build adjacency list for graph traversal Returns map: individual <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> â†’ set of connected individual IRIs. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="251" column="24" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="297" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1aef152e0bb00743472edaea6773957821" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt;</type>
        <definition>std::unordered_set&lt; IRI &gt; ista::owl2::OntologyFilter::bfsTraversal</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;seeds, int depth, const std::unordered_map&lt; IRI, std::unordered_set&lt; IRI &gt; &gt; &amp;adj_list) const</argsstring>
        <name>bfsTraversal</name>
        <qualifiedname>ista::owl2::OntologyFilter::bfsTraversal</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>seeds</declname>
        </param>
        <param>
          <type>int</type>
          <declname>depth</declname>
        </param>
        <param>
          <type>const std::unordered_map&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref>, std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &gt; &amp;</type>
          <declname>adj_list</declname>
        </param>
        <briefdescription>
<para>BFS traversal from seed nodes up to depth. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="256" column="24" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="320" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a9bb1b404f5e8bc314ed9ea2e94a4f57d" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt;</type>
        <definition>std::unordered_set&lt; IRI &gt; ista::owl2::OntologyFilter::findPath</definition>
        <argsstring>(const IRI &amp;start, const IRI &amp;end, const std::unordered_map&lt; IRI, std::unordered_set&lt; IRI &gt; &gt; &amp;adj_list) const</argsstring>
        <name>findPath</name>
        <qualifiedname>ista::owl2::OntologyFilter::findPath</qualifiedname>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>start</declname>
        </param>
        <param>
          <type>const <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &amp;</type>
          <declname>end</declname>
        </param>
        <param>
          <type>const std::unordered_map&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref>, std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &gt; &amp;</type>
          <declname>adj_list</declname>
        </param>
        <briefdescription>
<para>BFS to find path between two nodes Returns set of all individuals on shortest path(s). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="265" column="24" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="359" bodyend="409"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a6b609bc7135852e74a88550360644852" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool ista::owl2::OntologyFilter::axiomReferencesIndividuals</definition>
        <argsstring>(const AxiomPtr &amp;axiom, const std::unordered_set&lt; IRI &gt; &amp;individuals) const</argsstring>
        <name>axiomReferencesIndividuals</name>
        <qualifiedname>ista::owl2::OntologyFilter::axiomReferencesIndividuals</qualifiedname>
        <param>
          <type>const <ref refid="namespaceista_1_1owl2_1ae305b46823ac53f0c71aed391a90f835" kindref="member">AxiomPtr</ref> &amp;</type>
          <declname>axiom</declname>
        </param>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>individuals</declname>
        </param>
        <briefdescription>
<para>Check if an axiom references any of the target individuals. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="273" column="10" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="411" bodyend="424"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1aa3a435e0b5d9a6862a41876c78673645" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt;</type>
        <definition>std::unordered_set&lt; IRI &gt; ista::owl2::OntologyFilter::extractIndividualsFromAxiom</definition>
        <argsstring>(const AxiomPtr &amp;axiom) const</argsstring>
        <name>extractIndividualsFromAxiom</name>
        <qualifiedname>ista::owl2::OntologyFilter::extractIndividualsFromAxiom</qualifiedname>
        <param>
          <type>const <ref refid="namespaceista_1_1owl2_1ae305b46823ac53f0c71aed391a90f835" kindref="member">AxiomPtr</ref> &amp;</type>
          <declname>axiom</declname>
        </param>
        <briefdescription>
<para>Extract IRIs of individuals mentioned in an axiom. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="280" column="24" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="426" bodyend="483"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a5befc5d8a9d5051b27f7caa0fb0b1491" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structista_1_1owl2_1_1FilterResult" kindref="compound">FilterResult</ref></type>
        <definition>FilterResult ista::owl2::OntologyFilter::createFilteredOntology</definition>
        <argsstring>(const std::unordered_set&lt; IRI &gt; &amp;individuals) const</argsstring>
        <name>createFilteredOntology</name>
        <qualifiedname>ista::owl2::OntologyFilter::createFilteredOntology</qualifiedname>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>individuals</declname>
        </param>
        <briefdescription>
<para>Create filtered ontology from set of individuals Includes all axioms that reference these individuals. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="286" column="18" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="485" bodyend="550"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a0730b687680f64ede65a983c3293532f" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ista::owl2::OntologyFilter::addClassHierarchyAxioms</definition>
        <argsstring>(Ontology &amp;target, const std::unordered_set&lt; IRI &gt; &amp;class_iris) const</argsstring>
        <name>addClassHierarchyAxioms</name>
        <qualifiedname>ista::owl2::OntologyFilter::addClassHierarchyAxioms</qualifiedname>
        <param>
          <type><ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &amp;</type>
          <declname>target</declname>
        </param>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>class_iris</declname>
        </param>
        <briefdescription>
<para>Add class hierarchy axioms for the given classes. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="291" column="10" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="552" bodyend="599"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a7faa521a9b5f9038cef7c24a09110e07" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ista::owl2::OntologyFilter::addPropertyHierarchyAxioms</definition>
        <argsstring>(Ontology &amp;target, const std::unordered_set&lt; IRI &gt; &amp;property_iris) const</argsstring>
        <name>addPropertyHierarchyAxioms</name>
        <qualifiedname>ista::owl2::OntologyFilter::addPropertyHierarchyAxioms</qualifiedname>
        <param>
          <type><ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &amp;</type>
          <declname>target</declname>
        </param>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>property_iris</declname>
        </param>
        <briefdescription>
<para>Add property hierarchy axioms. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="298" column="10" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="601" bodyend="665"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1ad712044479c3788938255ed4b4a5e4af" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ista::owl2::OntologyFilter::addDeclarations</definition>
        <argsstring>(Ontology &amp;target, const std::unordered_set&lt; IRI &gt; &amp;entity_iris) const</argsstring>
        <name>addDeclarations</name>
        <qualifiedname>ista::owl2::OntologyFilter::addDeclarations</qualifiedname>
        <param>
          <type><ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &amp;</type>
          <declname>target</declname>
        </param>
        <param>
          <type>const std::unordered_set&lt; <ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref> &gt; &amp;</type>
          <declname>entity_iris</declname>
        </param>
        <briefdescription>
<para>Add declarations for referenced entities. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="305" column="10" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="667" bodyend="678"/>
      </memberdef>
      <memberdef kind="function" id="classista_1_1owl2_1_1OntologyFilter_1a6cf29292370190260724f1f4d9eb17e7" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ista::owl2::OntologyFilter::copyMetadata</definition>
        <argsstring>(Ontology &amp;target) const</argsstring>
        <name>copyMetadata</name>
        <qualifiedname>ista::owl2::OntologyFilter::copyMetadata</qualifiedname>
        <param>
          <type><ref refid="classista_1_1owl2_1_1Ontology" kindref="compound">Ontology</ref> &amp;</type>
          <declname>target</declname>
        </param>
        <briefdescription>
<para>Copy ontology metadata (<ref refid="classista_1_1owl2_1_1IRI" kindref="compound">IRI</ref>, version, prefixes, imports). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="312" column="10" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.cpp" bodystart="680" bodyend="701"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>High-performance ontology filtering and subgraph extraction. </para>
    </briefdescription>
    <detaileddescription>
<para>This class provides methods to filter ontologies based on various criteria, extracting subgraphs efficiently using hash-based lookups and graph algorithms.</para>
<para>Usage: <ref refid="classista_1_1owl2_1_1OntologyFilter" kindref="compound">OntologyFilter</ref> filter(ontology); auto result = filter.filterByIndividuals({iri1, iri2}); // result.ontology contains the filtered ontology </para>
    </detaileddescription>
    <location file="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" line="90" column="1" bodyfile="D:/projects/ista/lib/owl2/core/ontology_filter.hpp" bodystart="90" bodyend="313"/>
    <listofallmembers>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a0730b687680f64ede65a983c3293532f" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>addClassHierarchyAxioms</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1ad712044479c3788938255ed4b4a5e4af" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>addDeclarations</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a7faa521a9b5f9038cef7c24a09110e07" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>addPropertyHierarchyAxioms</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a05fbcd33f210d57cdf321e0d96297b60" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>applyFilter</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a6b609bc7135852e74a88550360644852" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>axiomReferencesIndividuals</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1aef152e0bb00743472edaea6773957821" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>bfsTraversal</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a3a68e5352cc8b7aa3b1e8666cdd8836e" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>buildAdjacencyList</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a6cf29292370190260724f1f4d9eb17e7" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>copyMetadata</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a5befc5d8a9d5051b27f7caa0fb0b1491" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>createFilteredOntology</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a8a7a81ea998c3436b63f0e581cc289a2" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>criteria_</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a75f1abdc1d4e8031350a0e4cde907ea6" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>excludeIndividuals</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a42f58574eeb431335d08f914dd4cf7f1" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>execute</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1aa3a435e0b5d9a6862a41876c78673645" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>extractIndividualsFromAxiom</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a97f9a68e6632707e6b50238cf9e57faa" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>extractNeighborhood</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a419895577ae3e0375f90ee0904040fbc" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>extractNeighborhood</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a11640efd18c237dcd1742cc07b52c65e" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>extractPath</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a6f6d0a43b2a623ad17cf80e8a0eff87b" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>filterByClasses</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a07975b01d94c1a58008728892c77f60b" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>filterByIndividuals</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1aa9bb64a055d688ee2012c389df99c5f9" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>filterByObjectProperty</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a1e8f46ed127f1d4c19f0cdce53adcb0d" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>filterByProperty</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a9bb1b404f5e8bc314ed9ea2e94a4f57d" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>findPath</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a1e50060e7d9bb34b82e3731fd2f67127" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>getAllIndividuals</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a16a45b4bdbcbbd29874511bc45161b94" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>getIndividualsOfClass</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1aef35424e4000eaab2e5e9a5396b2a053" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>getOntology</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a888c96adeb52623f9ae2d980f2b284d6" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>includeClassHierarchy</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a666abd422d7662f1adce40e97975c4f6" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>includeDeclarations</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1ac47d8b428dc9f048bf3d3544d92c01d1" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>includePropertyHierarchy</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1ad5e0765e3465ad335ea4d9b681eee02c" prot="private" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>ontology_</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a7143654057351b6d135895b291887a97" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>OntologyFilter</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a7c6058f61917b34ee12ac3e600f5d1c3" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>OntologyFilter</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a00f2153862d854e1618bc9f8b24ad5b5" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>randomSample</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1acb0e23e9328763b75ddf35f858fa276a" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>withClasses</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a5a68f5fed2201b121f54c872af137f1b" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>withIndividuals</name></member>
      <member refid="classista_1_1owl2_1_1OntologyFilter_1a898402f739529104fe3288c67a945d1b" prot="public" virt="non-virtual"><scope>ista::owl2::OntologyFilter</scope><name>withMaxDepth</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
